esphome:
  name: rolladen

esp32:
  board: esp32dev

api:

logger:
 

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
ota:
  platform: esphome

web_server:
    port: 80
    version: 3


button:
  - platform: restart
    name: "Restart"

sensor:
  - platform: wifi_signal
    name: "WiFi Signal Sensor"
    update_interval: 60s

  - platform: uptime
    name: Uptime Sensor

  - platform: pulse_counter
    pin:
      number: GPIO34
    unit_of_measurement: 'km/h' ##change to m/s if metric
    name: 'Wind sensor'
    icon: 'mdi:weather-windy'
    id: windsesnor
    count_mode:
      rising_edge: DISABLE
      falling_edge: INCREMENT
    internal_filter: 5us
    update_interval: 2s
    #rotations_per_sec = pulses/2/60
    #circ_m=0.09*2*3.14 = 0.5652
    #mps = 1.18*circ_m*rotations_per_sec
    #mps = 1.18*0.5652/2/60 =0,0055578
    filters:
      - multiply: 0.0055578 #use for m/s
      - multiply: 3.6 #user km/h
      # - multiply: 2.237 #m/s to mph
      # - sliding_window_moving_average:
      #     window_size: 4
      #     send_every: 1
      # - multiply: 0.04973 #1.492mph switch to close 1/sec per spec, pulse/sec (/60/2)*1.492
      # - multiply: 0.0124327986 #m/s * mph conversion

text_sensor:
  - platform: wifi_info
    ip_address:
      name: ESP IP Address
    ssid:
      name: ESP Connected SSID
    bssid:
      name: ESP Connected BSSID
    mac_address:
      name: ESP Mac Wifi Address
    scan_results:
      name: ESP Latest Scan Results

globals:
  - id: wohnzimmer_updown
    type: int
    restore_value: no
    initial_value: '0'
  - id: schlafzimmer_updown
    type: int
    restore_value: no
    initial_value: '0'
  - id: esszimmer_updown
    type: int
    restore_value: no
    initial_value: '0'


binary_sensor:
- platform: homeassistant
  name: "ALL_UP"
  entity_id: binary_sensor.all_cover_up
  id: allup
  on_press:
    then:
      - switch.turn_on: open_cover_wohnzimmer
      - switch.turn_on: open_cover_esszimmer
      - switch.turn_on: open_cover_schlafzimmer
  on_release:
    then:
      - switch.turn_off: open_cover_wohnzimmer
      - switch.turn_off: open_cover_esszimmer
      - switch.turn_off: open_cover_schlafzimmer
- platform: gpio
  name: "Esszimmer_runter"
  pin:
    number: GPIO16
    inverted: true
    mode:
        input: true
        pullup: true
  id: esszimmer_down
  filters:
      - delayed_on: 30ms
  on_press:
    then:
      - lambda: |
          if (id(cover_esszimmer).current_operation == COVER_OPERATION_IDLE) {
             if (id(esszimmer_updown)==0){
                auto call = id(cover_esszimmer).make_call();
                call.set_command_close();
                call.perform();
                id(esszimmer_updown)=1;
              }
              else
              {
                auto call = id(cover_esszimmer).make_call();
                call.set_command_open();
                call.perform();
                id(esszimmer_updown)=0;
              }
          } else {
              auto call = id(cover_esszimmer).make_call();
              call.set_command_stop();
              call.perform();
          }
  on_release:
   then:
      - lambda: |
           //   auto call = id(cover_esszimmer).make_call();
           //   call.set_command_stop();
           //   call.perform();
  on_double_click:
    min_length: 50ms
    max_length: 350ms
    then:
      - lambda: |
              auto call = id(cover_esszimmer).make_call();
              call.set_command_close();
              call.perform();

- platform: gpio
  name: "Esszimmer_rauf"
  pin:
    number: GPIO17
    inverted: true
    mode:
        input: true
        pullup: true
  id: esszimmer_up
  filters:
      - delayed_on: 30ms
  on_press:
    then:
      - lambda: |
          if (id(cover_esszimmer).current_operation == COVER_OPERATION_IDLE) {
              auto call = id(cover_esszimmer).make_call();
              call.set_command_open();
              call.perform();
          } else {
              auto call = id(cover_esszimmer).make_call();
              call.set_command_stop();
              call.perform();
          }
  on_release:
   then:
      - lambda: |
              auto call = id(cover_esszimmer).make_call();
              call.set_command_stop();
              call.perform();
  on_double_click:
    min_length: 50ms
    max_length: 350ms
    then:
      - lambda: |
              auto call = id(cover_esszimmer).make_call();
              call.set_command_open();
              call.perform();


- platform: gpio
  name: "Wohnzimmer_runter"
  pin:
    number: GPIO18
    inverted: true
    mode:
        input: true
        pullup: true
  id: wohnzimmer_down
  filters:
      - delayed_on: 30ms
  on_press:
    then:
      - lambda: |
          if (id(cover_wohnzimmer).current_operation == COVER_OPERATION_IDLE) {
          if (id(wohnzimmer_updown)==0){
                auto call = id(cover_wohnzimmer).make_call();
                call.set_command_close();
                call.perform();
                id(wohnzimmer_updown)=1;
              }
              else
              {
                auto call = id(cover_wohnzimmer).make_call();
                call.set_command_open();
                call.perform();
                id(wohnzimmer_updown)=0;
              }
          } else {
              auto call = id(cover_wohnzimmer).make_call();
              call.set_command_stop();
              call.perform();
          }
  on_release:
   then:
      - lambda: |
              // auto call = id(cover_wohnzimmer).make_call();
              // call.set_command_stop();
              // call.perform();
  on_double_click:
    min_length: 50ms
    max_length: 350ms
    then:
      - lambda: |
              auto call = id(cover_wohnzimmer).make_call();
              call.set_command_close();
              call.perform();
- platform: gpio
  name: "Wohnzimmer_rauf"
  pin:
    number: GPIO19
    inverted: true
    mode:
        input: true
        pullup: true
  id: wohnzimmer_up
  filters:
      - delayed_on: 30ms
  on_press:
    then:
      - lambda: |
          if (id(cover_wohnzimmer).current_operation == COVER_OPERATION_IDLE) {
              auto call = id(cover_wohnzimmer).make_call();
              call.set_command_open();
              call.perform();
          } else {
              auto call = id(cover_wohnzimmer).make_call();
              call.set_command_stop();
              call.perform();
          }
  on_release:
   then:
      - lambda: |
              auto call = id(cover_wohnzimmer).make_call();
              call.set_command_stop();
              call.perform();
  on_double_click:
    min_length: 50ms
    max_length: 350ms
    then:
      - lambda: |
              auto call = id(cover_wohnzimmer).make_call();
              call.set_command_open();
              call.perform();

- platform: gpio
  name: "Schlafzimmer_runter"
  pin:
    number: GPIO22
    inverted: true
    mode:
        input: true
        pullup: true
  id: schlafzimmer_down
  filters:
      - delayed_on: 30ms
  on_press:
    then:
      - lambda: |
          if (id(cover_schlafzimmer).current_operation == COVER_OPERATION_IDLE) {
            if (id(schlafzimmer_updown)==0){
              auto call = id(cover_schlafzimmer).make_call();
              call.set_command_close();
              call.perform();
              id(schlafzimmer_updown)=1;
            } else {
              auto call = id(cover_schlafzimmer).make_call();
              call.set_command_open();
              call.perform();
              id(schlafzimmer_updown)=0;
            }
          } else {
              auto call = id(cover_schlafzimmer).make_call();
              call.set_command_stop();
              call.perform();
          }
  on_release:
   then:
      - lambda: |
              // auto call = id(cover_schlafzimmer).make_call();
              // call.set_command_stop();
              // call.perform();
  on_double_click:
    min_length: 50ms
    max_length: 350ms
    then:
      - lambda: |
              auto call = id(cover_schlafzimmer).make_call();
              call.set_command_close();
              call.perform();
- platform: gpio
  name: "Schlafzimmer_rauf"
  pin:
    number: GPIO23
    inverted: true
    mode:
        input: true
        pullup: true
  id: schlafzimmer_up
  filters:
      - delayed_on: 30ms
  on_press:
    then:
      - lambda: |
          if (id(cover_schlafzimmer).current_operation == COVER_OPERATION_IDLE) {
              auto call = id(cover_schlafzimmer).make_call();
              call.set_command_open();
              call.perform();
          } else {
              auto call = id(cover_schlafzimmer).make_call();
              call.set_command_stop();
              call.perform();
          }
  on_release:
   then:
      - lambda: |
              auto call = id(cover_schlafzimmer).make_call();
              call.set_command_stop();
              call.perform();
  on_double_click:
    min_length: 50ms
    max_length: 350ms
    then:
      - lambda: |
              auto call = id(cover_schlafzimmer).make_call();
              call.set_command_open();
              call.perform();
#- platform: gpio
#  name: "Windw√§chter"
#  pin:
#    number: GPIO34
#    inverted: true
#  id: windwaechter
#  filters:
#      - delayed_on: 30ms
#  on_press:
#    then:
#      - lambda: |
#          auto call1 = id(cover_schlafzimmer).make_call();
#            call1.set_command_open();
#            call1.perform();
#            auto call2 = id(cover_wohnzimmer).make_call();
#            call2.set_command_open();
#            call2.perform();
#            auto call3 = id(cover_esszimmer).make_call();
#            call3.set_command_open();
#            call3.perform();




switch:
- platform: gpio
  pin: GPIO13
  interlock: &interlock_esszimmer [open_cover_esszimmer, close_cover_esszimmer]
  id: open_cover_esszimmer
  inverted: yes
- platform: gpio
  pin: GPIO27
  interlock: *interlock_esszimmer
  id: close_cover_esszimmer
  inverted: yes
- platform: gpio
  pin: GPIO26
  interlock: &interlock_wohnzimmer [open_cover_wohnzimmer, close_cover_wohnzimmer]
  id: open_cover_wohnzimmer
  inverted: yes
- platform: gpio
  pin: GPIO25
  interlock: *interlock_wohnzimmer
  id: close_cover_wohnzimmer
  inverted: yes
- platform: gpio
  pin: GPIO33
  interlock: &interlock_schlafzimmer [open_cover_schlafzimmer, close_cover_schlafzimmer]
  id: open_cover_schlafzimmer
  inverted: yes
- platform: gpio
  pin: GPIO32
  interlock: *interlock_schlafzimmer
  id: close_cover_schlafzimmer
  inverted: yes

cover:
- platform: time_based
  name: "Esszimmer"
  id: cover_esszimmer
  open_action:
    - switch.turn_on: open_cover_esszimmer
  open_duration: 59s
  close_action:
    - switch.turn_on: close_cover_esszimmer
  close_duration: 57s
  stop_action:
    - switch.turn_off: open_cover_esszimmer
    - switch.turn_off: close_cover_esszimmer
- platform: time_based
  name: "Wohnzimmer"
  id: cover_wohnzimmer
  open_action:
    - switch.turn_on: open_cover_wohnzimmer
  open_duration: 39s
  close_action:
    - switch.turn_on: close_cover_wohnzimmer
  close_duration: 38s
  stop_action:
    - switch.turn_off: open_cover_wohnzimmer
    - switch.turn_off: close_cover_wohnzimmer
- platform: time_based
  name: "Schlafzimmer"
  id: cover_schlafzimmer
  open_action:
    - switch.turn_on: open_cover_schlafzimmer
  open_duration: 39s
  close_action:
    - switch.turn_on: close_cover_schlafzimmer
  close_duration: 38s
  stop_action:
    - switch.turn_off: open_cover_schlafzimmer
    - switch.turn_off: close_cover_schlafzimmer

